"""
This file is generated by generator/run.py based on the Chrome DevTools Protocol.

Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
breakpoints, stepping through execution, exploring stack traces, etc.
https://chromedevtools.github.io/devtools-protocol/tot/Debugger/

***************************************************
                    Methods
***************************************************
"""
from __future__ import annotations

from typing import Literal

from cdpkit.protocol._types import (
    Debugger,
    Runtime,
)
from cdpkit.protocol.base import CDPMethod, InputModel, OutputModel


class ContinueToLocationInput(InputModel):

    location: Debugger.Location
    targetCallFrames: Literal['any', 'current'] | None = None


class ContinueToLocation(CDPMethod[None]):
    """ Continues execution until specific location is reached. """

    INPUT_VALIDATOR = ContinueToLocationInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        location: Debugger.Location,
        target_call_frames: Literal['any', 'current'] | None = None
    ):
        super().__init__(
            location=location,
            targetCallFrames=target_call_frames
        )


class Disable(CDPMethod[None]):
    """ Disables debugger for given page. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class EnableInput(InputModel):

    maxScriptsCacheSize: float | None = None  # experimental


class EnableOutput(OutputModel):

    debuggerId: Runtime.UniqueDebuggerId | None = None  # experimental


class Enable(CDPMethod[EnableOutput]):
    """ Enables debugger for the given page. Clients should not assume that the debugging has been
    enabled until the result for this command is received. """

    INPUT_VALIDATOR = EnableInput
    OUTPUT_VALIDATOR = EnableOutput

    def __init__(
        self,
        *,
        max_scripts_cache_size: float | None = None
    ):
        super().__init__(
            maxScriptsCacheSize=max_scripts_cache_size
        )


class EvaluateOnCallFrameInput(InputModel):

    callFrameId: Debugger.CallFrameId
    expression: str
    objectGroup: str | None = None
    includeCommandLineAPI: bool | None = None
    silent: bool | None = None
    returnByValue: bool | None = None
    generatePreview: bool | None = None  # experimental
    throwOnSideEffect: bool | None = None
    timeout: Runtime.TimeDelta | None = None  # experimental


class EvaluateOnCallFrameOutput(OutputModel):

    result: Runtime.RemoteObject
    exceptionDetails: Runtime.ExceptionDetails | None = None


class EvaluateOnCallFrame(CDPMethod[EvaluateOnCallFrameOutput]):
    """ Evaluates expression on a given call frame. """

    INPUT_VALIDATOR = EvaluateOnCallFrameInput
    OUTPUT_VALIDATOR = EvaluateOnCallFrameOutput

    def __init__(
        self,
        *,
        call_frame_id: Debugger.CallFrameId,
        expression: str,
        object_group: str | None = None,
        include_command_line_api: bool | None = None,
        silent: bool | None = None,
        return_by_value: bool | None = None,
        generate_preview: bool | None = None,
        throw_on_side_effect: bool | None = None,
        timeout: Runtime.TimeDelta | None = None
    ):
        super().__init__(
            callFrameId=call_frame_id,
            expression=expression,
            objectGroup=object_group,
            includeCommandLineAPI=include_command_line_api,
            silent=silent,
            returnByValue=return_by_value,
            generatePreview=generate_preview,
            throwOnSideEffect=throw_on_side_effect,
            timeout=timeout
        )


class GetPossibleBreakpointsInput(InputModel):

    start: Debugger.Location
    end: Debugger.Location | None = None
    restrictToFunction: bool | None = None


class GetPossibleBreakpointsOutput(OutputModel):

    locations: list[Debugger.BreakLocation]


class GetPossibleBreakpoints(CDPMethod[GetPossibleBreakpointsOutput]):
    """ Returns possible locations for breakpoint. scriptId in start and end range locations should be
    the same. """

    INPUT_VALIDATOR = GetPossibleBreakpointsInput
    OUTPUT_VALIDATOR = GetPossibleBreakpointsOutput

    def __init__(
        self,
        *,
        start: Debugger.Location,
        end: Debugger.Location | None = None,
        restrict_to_function: bool | None = None
    ):
        super().__init__(
            start=start,
            end=end,
            restrictToFunction=restrict_to_function
        )


class GetScriptSourceInput(InputModel):

    scriptId: Runtime.ScriptId


class GetScriptSourceOutput(OutputModel):

    scriptSource: str
    bytecode: str | None = None


class GetScriptSource(CDPMethod[GetScriptSourceOutput]):
    """ Returns source for the script with given id. """

    INPUT_VALIDATOR = GetScriptSourceInput
    OUTPUT_VALIDATOR = GetScriptSourceOutput

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId
    ):
        super().__init__(
            scriptId=script_id
        )


class DisassembleWasmModuleInput(InputModel):

    scriptId: Runtime.ScriptId


class DisassembleWasmModuleOutput(OutputModel):

    streamId: str | None = None
    totalNumberOfLines: int
    functionBodyOffsets: list[int]
    chunk: Debugger.WasmDisassemblyChunk


class DisassembleWasmModule(CDPMethod[DisassembleWasmModuleOutput]):  # experimental

    INPUT_VALIDATOR = DisassembleWasmModuleInput
    OUTPUT_VALIDATOR = DisassembleWasmModuleOutput

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId
    ):
        super().__init__(
            scriptId=script_id
        )


class NextWasmDisassemblyChunkInput(InputModel):

    streamId: str


class NextWasmDisassemblyChunkOutput(OutputModel):

    chunk: Debugger.WasmDisassemblyChunk


class NextWasmDisassemblyChunk(CDPMethod[NextWasmDisassemblyChunkOutput]):  # experimental
    """ Disassemble the next chunk of lines for the module corresponding to the
    stream. If disassembly is complete, this API will invalidate the streamId
    and return an empty chunk. Any subsequent calls for the now invalid stream
    will return errors. """

    INPUT_VALIDATOR = NextWasmDisassemblyChunkInput
    OUTPUT_VALIDATOR = NextWasmDisassemblyChunkOutput

    def __init__(
        self,
        *,
        stream_id: str
    ):
        super().__init__(
            streamId=stream_id
        )


class GetWasmBytecodeInput(InputModel):

    scriptId: Runtime.ScriptId


class GetWasmBytecodeOutput(OutputModel):

    bytecode: str


class GetWasmBytecode(CDPMethod[GetWasmBytecodeOutput]):  # deprecated
    """ This command is deprecated. Use getScriptSource instead. """

    INPUT_VALIDATOR = GetWasmBytecodeInput
    OUTPUT_VALIDATOR = GetWasmBytecodeOutput

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId
    ):
        super().__init__(
            scriptId=script_id
        )


class GetStackTraceInput(InputModel):

    stackTraceId: Runtime.StackTraceId


class GetStackTraceOutput(OutputModel):

    stackTrace: Runtime.StackTrace


class GetStackTrace(CDPMethod[GetStackTraceOutput]):  # experimental
    """ Returns stack trace with given `stackTraceId`. """

    INPUT_VALIDATOR = GetStackTraceInput
    OUTPUT_VALIDATOR = GetStackTraceOutput

    def __init__(
        self,
        *,
        stack_trace_id: Runtime.StackTraceId
    ):
        super().__init__(
            stackTraceId=stack_trace_id
        )


class Pause(CDPMethod[None]):
    """ Stops on the next JavaScript statement. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class PauseOnAsyncCallInput(InputModel):

    parentStackTraceId: Runtime.StackTraceId


class PauseOnAsyncCall(CDPMethod[None]):  # experimental deprecated

    INPUT_VALIDATOR = PauseOnAsyncCallInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        parent_stack_trace_id: Runtime.StackTraceId
    ):
        super().__init__(
            parentStackTraceId=parent_stack_trace_id
        )


class RemoveBreakpointInput(InputModel):

    breakpointId: Debugger.BreakpointId


class RemoveBreakpoint(CDPMethod[None]):
    """ Removes JavaScript breakpoint. """

    INPUT_VALIDATOR = RemoveBreakpointInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        breakpoint_id: Debugger.BreakpointId
    ):
        super().__init__(
            breakpointId=breakpoint_id
        )


class RestartFrameInput(InputModel):

    callFrameId: Debugger.CallFrameId
    mode: Literal['StepInto'] | None = None  # experimental


class RestartFrameOutput(OutputModel):

    callFrames: list[Debugger.CallFrame]  # deprecated
    asyncStackTrace: Runtime.StackTrace | None = None  # deprecated
    asyncStackTraceId: Runtime.StackTraceId | None = None  # deprecated


class RestartFrame(CDPMethod[RestartFrameOutput]):
    """ Restarts particular call frame from the beginning. The old, deprecated
    behavior of `restartFrame` is to stay paused and allow further CDP commands
    after a restart was scheduled. This can cause problems with restarting, so
    we now continue execution immediatly after it has been scheduled until we
    reach the beginning of the restarted frame.

    To stay back-wards compatible, `restartFrame` now expects a `mode`
    parameter to be present. If the `mode` parameter is missing, `restartFrame`
    errors out.

    The various return values are deprecated and `callFrames` is always empty.
    Use the call frames from the `Debugger#paused` events instead, that fires
    once V8 pauses at the beginning of the restarted function. """

    INPUT_VALIDATOR = RestartFrameInput
    OUTPUT_VALIDATOR = RestartFrameOutput

    def __init__(
        self,
        *,
        call_frame_id: Debugger.CallFrameId,
        mode: Literal['StepInto'] | None = None
    ):
        super().__init__(
            callFrameId=call_frame_id,
            mode=mode
        )


class ResumeInput(InputModel):

    terminateOnResume: bool | None = None


class Resume(CDPMethod[None]):
    """ Resumes JavaScript execution. """

    INPUT_VALIDATOR = ResumeInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        terminate_on_resume: bool | None = None
    ):
        super().__init__(
            terminateOnResume=terminate_on_resume
        )


class SearchInContentInput(InputModel):

    scriptId: Runtime.ScriptId
    query: str
    caseSensitive: bool | None = None
    isRegex: bool | None = None


class SearchInContentOutput(OutputModel):

    result: list[Debugger.SearchMatch]


class SearchInContent(CDPMethod[SearchInContentOutput]):
    """ Searches for given string in script content. """

    INPUT_VALIDATOR = SearchInContentInput
    OUTPUT_VALIDATOR = SearchInContentOutput

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId,
        query: str,
        case_sensitive: bool | None = None,
        is_regex: bool | None = None
    ):
        super().__init__(
            scriptId=script_id,
            query=query,
            caseSensitive=case_sensitive,
            isRegex=is_regex
        )


class SetAsyncCallStackDepthInput(InputModel):

    maxDepth: int


class SetAsyncCallStackDepth(CDPMethod[None]):
    """ Enables or disables async call stacks tracking. """

    INPUT_VALIDATOR = SetAsyncCallStackDepthInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        max_depth: int
    ):
        super().__init__(
            maxDepth=max_depth
        )


class SetBlackboxExecutionContextsInput(InputModel):

    uniqueIds: list[str]


class SetBlackboxExecutionContexts(CDPMethod[None]):  # experimental
    """ Replace previous blackbox execution contexts with passed ones. Forces backend to skip
    stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful. """

    INPUT_VALIDATOR = SetBlackboxExecutionContextsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        unique_ids: list[str]
    ):
        super().__init__(
            uniqueIds=unique_ids
        )


class SetBlackboxPatternsInput(InputModel):

    patterns: list[str]
    skipAnonymous: bool | None = None


class SetBlackboxPatterns(CDPMethod[None]):  # experimental
    """ Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
    scripts with url matching one of the patterns. VM will try to leave blackboxed script by
    performing 'step in' several times, finally resorting to 'step out' if unsuccessful. """

    INPUT_VALIDATOR = SetBlackboxPatternsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        patterns: list[str],
        skip_anonymous: bool | None = None
    ):
        super().__init__(
            patterns=patterns,
            skipAnonymous=skip_anonymous
        )


class SetBlackboxedRangesInput(InputModel):

    scriptId: Runtime.ScriptId
    positions: list[Debugger.ScriptPosition]


class SetBlackboxedRanges(CDPMethod[None]):  # experimental
    """ Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
    scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
    Positions array contains positions where blackbox state is changed. First interval isn't
    blackboxed. Array should be sorted. """

    INPUT_VALIDATOR = SetBlackboxedRangesInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId,
        positions: list[Debugger.ScriptPosition]
    ):
        super().__init__(
            scriptId=script_id,
            positions=positions
        )


class SetBreakpointInput(InputModel):

    location: Debugger.Location
    condition: str | None = None


class SetBreakpointOutput(OutputModel):

    breakpointId: Debugger.BreakpointId
    actualLocation: Debugger.Location


class SetBreakpoint(CDPMethod[SetBreakpointOutput]):
    """ Sets JavaScript breakpoint at a given location. """

    INPUT_VALIDATOR = SetBreakpointInput
    OUTPUT_VALIDATOR = SetBreakpointOutput

    def __init__(
        self,
        *,
        location: Debugger.Location,
        condition: str | None = None
    ):
        super().__init__(
            location=location,
            condition=condition
        )


class SetInstrumentationBreakpointInput(InputModel):

    instrumentation: Literal['beforeScriptExecution', 'beforeScriptWithSourceMapExecution']


class SetInstrumentationBreakpointOutput(OutputModel):

    breakpointId: Debugger.BreakpointId


class SetInstrumentationBreakpoint(CDPMethod[SetInstrumentationBreakpointOutput]):
    """ Sets instrumentation breakpoint. """

    INPUT_VALIDATOR = SetInstrumentationBreakpointInput
    OUTPUT_VALIDATOR = SetInstrumentationBreakpointOutput

    def __init__(
        self,
        *,
        instrumentation: Literal['beforeScriptExecution', 'beforeScriptWithSourceMapExecution']
    ):
        super().__init__(
            instrumentation=instrumentation
        )


class SetBreakpointByUrlInput(InputModel):

    lineNumber: int
    url: str | None = None
    urlRegex: str | None = None
    scriptHash: str | None = None
    columnNumber: int | None = None
    condition: str | None = None


class SetBreakpointByUrlOutput(OutputModel):

    breakpointId: Debugger.BreakpointId
    locations: list[Debugger.Location]


class SetBreakpointByUrl(CDPMethod[SetBreakpointByUrlOutput]):
    """ Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
    command is issued, all existing parsed scripts will have breakpoints resolved and returned in
    `locations` property. Further matching script parsing will result in subsequent
    `breakpointResolved` events issued. This logical breakpoint will survive page reloads. """

    INPUT_VALIDATOR = SetBreakpointByUrlInput
    OUTPUT_VALIDATOR = SetBreakpointByUrlOutput

    def __init__(
        self,
        *,
        line_number: int,
        url: str | None = None,
        url_regex: str | None = None,
        script_hash: str | None = None,
        column_number: int | None = None,
        condition: str | None = None
    ):
        super().__init__(
            lineNumber=line_number,
            url=url,
            urlRegex=url_regex,
            scriptHash=script_hash,
            columnNumber=column_number,
            condition=condition
        )


class SetBreakpointOnFunctionCallInput(InputModel):

    objectId: Runtime.RemoteObjectId
    condition: str | None = None


class SetBreakpointOnFunctionCallOutput(OutputModel):

    breakpointId: Debugger.BreakpointId


class SetBreakpointOnFunctionCall(CDPMethod[SetBreakpointOnFunctionCallOutput]):  # experimental
    """ Sets JavaScript breakpoint before each call to the given function.
    If another function was created from the same source as a given one,
    calling it will also trigger the breakpoint. """

    INPUT_VALIDATOR = SetBreakpointOnFunctionCallInput
    OUTPUT_VALIDATOR = SetBreakpointOnFunctionCallOutput

    def __init__(
        self,
        *,
        object_id: Runtime.RemoteObjectId,
        condition: str | None = None
    ):
        super().__init__(
            objectId=object_id,
            condition=condition
        )


class SetBreakpointsActiveInput(InputModel):

    active: bool


class SetBreakpointsActive(CDPMethod[None]):
    """ Activates / deactivates all breakpoints on the page. """

    INPUT_VALIDATOR = SetBreakpointsActiveInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        active: bool
    ):
        super().__init__(
            active=active
        )


class SetPauseOnExceptionsInput(InputModel):

    state: Literal['none', 'caught', 'uncaught', 'all']


class SetPauseOnExceptions(CDPMethod[None]):
    """ Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
    or caught exceptions, no exceptions. Initial pause on exceptions state is `none`. """

    INPUT_VALIDATOR = SetPauseOnExceptionsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        state: Literal['none', 'caught', 'uncaught', 'all']
    ):
        super().__init__(
            state=state
        )


class SetReturnValueInput(InputModel):

    newValue: Runtime.CallArgument


class SetReturnValue(CDPMethod[None]):  # experimental
    """ Changes return value in top frame. Available only at return break position. """

    INPUT_VALIDATOR = SetReturnValueInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        new_value: Runtime.CallArgument
    ):
        super().__init__(
            newValue=new_value
        )


class SetScriptSourceInput(InputModel):

    scriptId: Runtime.ScriptId
    scriptSource: str
    dryRun: bool | None = None
    allowTopFrameEditing: bool | None = None  # experimental


class SetScriptSourceOutput(OutputModel):

    callFrames: list[Debugger.CallFrame] | None = None  # deprecated
    stackChanged: bool | None = None  # deprecated
    asyncStackTrace: Runtime.StackTrace | None = None  # deprecated
    asyncStackTraceId: Runtime.StackTraceId | None = None  # deprecated
    status: Literal['Ok', 'CompileError', 'BlockedByActiveGenerator', 'BlockedByActiveFunction', 'BlockedByTopLevelEsModuleChange'] | None = None  # experimental
    exceptionDetails: Runtime.ExceptionDetails | None = None


class SetScriptSource(CDPMethod[SetScriptSourceOutput]):
    """ Edits JavaScript source live.

    In general, functions that are currently on the stack can not be edited with
    a single exception: If the edited function is the top-most stack frame and
    that is the only activation of that function on the stack. In this case
    the live edit will be successful and a `Debugger.restartFrame` for the
    top-most function is automatically triggered. """

    INPUT_VALIDATOR = SetScriptSourceInput
    OUTPUT_VALIDATOR = SetScriptSourceOutput

    def __init__(
        self,
        *,
        script_id: Runtime.ScriptId,
        script_source: str,
        dry_run: bool | None = None,
        allow_top_frame_editing: bool | None = None
    ):
        super().__init__(
            scriptId=script_id,
            scriptSource=script_source,
            dryRun=dry_run,
            allowTopFrameEditing=allow_top_frame_editing
        )


class SetSkipAllPausesInput(InputModel):

    skip: bool


class SetSkipAllPauses(CDPMethod[None]):
    """ Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). """

    INPUT_VALIDATOR = SetSkipAllPausesInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        skip: bool
    ):
        super().__init__(
            skip=skip
        )


class SetVariableValueInput(InputModel):

    scopeNumber: int
    variableName: str
    newValue: Runtime.CallArgument
    callFrameId: Debugger.CallFrameId


class SetVariableValue(CDPMethod[None]):
    """ Changes value of variable in a callframe. Object-based scopes are not supported and must be
    mutated manually. """

    INPUT_VALIDATOR = SetVariableValueInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        scope_number: int,
        variable_name: str,
        new_value: Runtime.CallArgument,
        call_frame_id: Debugger.CallFrameId
    ):
        super().__init__(
            scopeNumber=scope_number,
            variableName=variable_name,
            newValue=new_value,
            callFrameId=call_frame_id
        )


class StepIntoInput(InputModel):

    breakOnAsyncCall: bool | None = None  # experimental
    skipList: list[Debugger.LocationRange] | None = None  # experimental


class StepInto(CDPMethod[None]):
    """ Steps into the function call. """

    INPUT_VALIDATOR = StepIntoInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        break_on_async_call: bool | None = None,
        skip_list: list[Debugger.LocationRange] | None = None
    ):
        super().__init__(
            breakOnAsyncCall=break_on_async_call,
            skipList=skip_list
        )


class StepOut(CDPMethod[None]):
    """ Steps out of the function call. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class StepOverInput(InputModel):

    skipList: list[Debugger.LocationRange] | None = None  # experimental


class StepOver(CDPMethod[None]):
    """ Steps over the statement. """

    INPUT_VALIDATOR = StepOverInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        skip_list: list[Debugger.LocationRange] | None = None
    ):
        super().__init__(
            skipList=skip_list
        )
