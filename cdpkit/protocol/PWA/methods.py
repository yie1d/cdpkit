"""
This file is generated by generator/run.py based on the Chrome DevTools Protocol.

This domain allows interacting with the browser to control PWAs.
https://chromedevtools.github.io/devtools-protocol/tot/PWA/

***************************************************
                    Methods
***************************************************
"""
from __future__ import annotations

from cdpkit.protocol._types import (
    PWA,
    Target,
)
from cdpkit.protocol.base import CDPMethod, InputModel, OutputModel


class GetOsAppStateInput(InputModel):

    manifestId: str


class GetOsAppStateOutput(OutputModel):

    badgeCount: int
    fileHandlers: list[PWA.FileHandler]


class GetOsAppState(CDPMethod[GetOsAppStateOutput]):
    """ Returns the following OS state for the given manifest id. """

    INPUT_VALIDATOR = GetOsAppStateInput
    OUTPUT_VALIDATOR = GetOsAppStateOutput

    def __init__(
        self,
        *,
        manifest_id: str
    ):
        super().__init__(
            manifestId=manifest_id
        )


class InstallInput(InputModel):

    manifestId: str
    installUrlOrBundleUrl: str | None = None


class Install(CDPMethod[None]):
    """ Installs the given manifest identity, optionally using the given installUrlOrBundleUrl

    IWA-specific install description:
    manifestId corresponds to isolated-app:// + web_package::SignedWebBundleId

    File installation mode:
    The installUrlOrBundleUrl can be either file:// or http(s):// pointing
    to a signed web bundle (.swbn). In this case SignedWebBundleId must correspond to
    The .swbn file's signing key.

    Dev proxy installation mode:
    installUrlOrBundleUrl must be http(s):// that serves dev mode IWA.
    web_package::SignedWebBundleId must be of type dev proxy.

    The advantage of dev proxy mode is that all changes to IWA
    automatically will be reflected in the running app without
    reinstallation.

    To generate bundle id for proxy mode:
    1. Generate 32 random bytes.
    2. Add a specific suffix 0x00 at the end.
    3. Encode the entire sequence using Base32 without padding.

    If Chrome is not in IWA dev
    mode, the installation will fail, regardless of the state of the allowlist. """

    INPUT_VALIDATOR = InstallInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        manifest_id: str,
        install_url_or_bundle_url: str | None = None
    ):
        super().__init__(
            manifestId=manifest_id,
            installUrlOrBundleUrl=install_url_or_bundle_url
        )


class UninstallInput(InputModel):

    manifestId: str


class Uninstall(CDPMethod[None]):
    """ Uninstalls the given manifest_id and closes any opened app windows. """

    INPUT_VALIDATOR = UninstallInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        manifest_id: str
    ):
        super().__init__(
            manifestId=manifest_id
        )


class LaunchInput(InputModel):

    manifestId: str
    url: str | None = None


class LaunchOutput(OutputModel):

    targetId: Target.TargetID


class Launch(CDPMethod[LaunchOutput]):
    """ Launches the installed web app, or an url in the same web app instead of the
    default start url if it is provided. Returns a page Target.TargetID which
    can be used to attach to via Target.attachToTarget or similar APIs. """

    INPUT_VALIDATOR = LaunchInput
    OUTPUT_VALIDATOR = LaunchOutput

    def __init__(
        self,
        *,
        manifest_id: str,
        url: str | None = None
    ):
        super().__init__(
            manifestId=manifest_id,
            url=url
        )


class LaunchFilesInAppInput(InputModel):

    manifestId: str
    files: list[str]


class LaunchFilesInAppOutput(OutputModel):

    targetIds: list[Target.TargetID]


class LaunchFilesInApp(CDPMethod[LaunchFilesInAppOutput]):
    """ Opens one or more local files from an installed web app identified by its
    manifestId. The web app needs to have file handlers registered to process
    the files. The API returns one or more page Target.TargetIDs which can be
    used to attach to via Target.attachToTarget or similar APIs.
    If some files in the parameters cannot be handled by the web app, they will
    be ignored. If none of the files can be handled, this API returns an error.
    If no files are provided as the parameter, this API also returns an error.

    According to the definition of the file handlers in the manifest file, one
    Target.TargetID may represent a page handling one or more files. The order
    of the returned Target.TargetIDs is not guaranteed.

    TODO(crbug.com/339454034): Check the existences of the input files. """

    INPUT_VALIDATOR = LaunchFilesInAppInput
    OUTPUT_VALIDATOR = LaunchFilesInAppOutput

    def __init__(
        self,
        *,
        manifest_id: str,
        files: list[str]
    ):
        super().__init__(
            manifestId=manifest_id,
            files=files
        )


class OpenCurrentPageInAppInput(InputModel):

    manifestId: str


class OpenCurrentPageInApp(CDPMethod[None]):
    """ Opens the current page in its web app identified by the manifest id, needs
    to be called on a page target. This function returns immediately without
    waiting for the app to finish loading. """

    INPUT_VALIDATOR = OpenCurrentPageInAppInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        manifest_id: str
    ):
        super().__init__(
            manifestId=manifest_id
        )


class ChangeAppUserSettingsInput(InputModel):

    manifestId: str
    linkCapturing: bool | None = None
    displayMode: PWA.DisplayMode | None = None


class ChangeAppUserSettings(CDPMethod[None]):
    """ Changes user settings of the web app identified by its manifestId. If the
    app was not installed, this command returns an error. Unset parameters will
    be ignored; unrecognized values will cause an error.

    Unlike the ones defined in the manifest files of the web apps, these
    settings are provided by the browser and controlled by the users, they
    impact the way the browser handling the web apps.

    See the comment of each parameter. """

    INPUT_VALIDATOR = ChangeAppUserSettingsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        manifest_id: str,
        link_capturing: bool | None = None,
        display_mode: PWA.DisplayMode | None = None
    ):
        super().__init__(
            manifestId=manifest_id,
            linkCapturing=link_capturing,
            displayMode=display_mode
        )
