"""
This file is generated by generator/run.py based on the Chrome DevTools Protocol.

Supports additional targets discovery and allows to attach to them.
https://chromedevtools.github.io/devtools-protocol/tot/Target/

***************************************************
                    Methods
***************************************************
"""
from __future__ import annotations

from cdpkit.protocol._types import (
    Browser,
    Target,
)
from cdpkit.protocol.base import CDPMethod, InputModel, OutputModel


class ActivateTargetInput(InputModel):

    targetId: Target.TargetID


class ActivateTarget(CDPMethod[None]):
    """ Activates (focuses) the target. """

    INPUT_VALIDATOR = ActivateTargetInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        target_id: Target.TargetID
    ):
        super().__init__(
            targetId=target_id
        )


class AttachToTargetInput(InputModel):

    targetId: Target.TargetID
    flatten: bool | None = None


class AttachToTargetOutput(OutputModel):

    sessionId: Target.SessionID


class AttachToTarget(CDPMethod[AttachToTargetOutput]):
    """ Attaches to the target with given id. """

    INPUT_VALIDATOR = AttachToTargetInput
    OUTPUT_VALIDATOR = AttachToTargetOutput

    def __init__(
        self,
        *,
        target_id: Target.TargetID,
        flatten: bool | None = None
    ):
        super().__init__(
            targetId=target_id,
            flatten=flatten
        )


class AttachToBrowserTargetOutput(OutputModel):

    sessionId: Target.SessionID


class AttachToBrowserTarget(CDPMethod[AttachToBrowserTargetOutput]):  # experimental
    """ Attaches to the browser target, only uses flat sessionId mode. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = AttachToBrowserTargetOutput


class CloseTargetInput(InputModel):

    targetId: Target.TargetID


class CloseTargetOutput(OutputModel):

    success: bool  # deprecated


class CloseTarget(CDPMethod[CloseTargetOutput]):
    """ Closes the target. If the target is a page that gets closed too. """

    INPUT_VALIDATOR = CloseTargetInput
    OUTPUT_VALIDATOR = CloseTargetOutput

    def __init__(
        self,
        *,
        target_id: Target.TargetID
    ):
        super().__init__(
            targetId=target_id
        )


class ExposeDevToolsProtocolInput(InputModel):

    targetId: Target.TargetID
    bindingName: str | None = None
    inheritPermissions: bool | None = None


class ExposeDevToolsProtocol(CDPMethod[None]):  # experimental
    """ Inject object to the target's main frame that provides a communication
    channel with browser target.

    Injected object will be available as `window[bindingName]`.

    The object has the following API:
    - `binding.send(json)` - a method to send messages over the remote debugging protocol
    - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. """

    INPUT_VALIDATOR = ExposeDevToolsProtocolInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        target_id: Target.TargetID,
        binding_name: str | None = None,
        inherit_permissions: bool | None = None
    ):
        super().__init__(
            targetId=target_id,
            bindingName=binding_name,
            inheritPermissions=inherit_permissions
        )


class CreateBrowserContextInput(InputModel):

    disposeOnDetach: bool | None = None  # experimental
    proxyServer: str | None = None  # experimental
    proxyBypassList: str | None = None  # experimental
    originsWithUniversalNetworkAccess: list[str] | None = None  # experimental


class CreateBrowserContextOutput(OutputModel):

    browserContextId: Browser.BrowserContextID


class CreateBrowserContext(CDPMethod[CreateBrowserContextOutput]):
    """ Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
    one. """

    INPUT_VALIDATOR = CreateBrowserContextInput
    OUTPUT_VALIDATOR = CreateBrowserContextOutput

    def __init__(
        self,
        *,
        dispose_on_detach: bool | None = None,
        proxy_server: str | None = None,
        proxy_bypass_list: str | None = None,
        origins_with_universal_network_access: list[str] | None = None
    ):
        super().__init__(
            disposeOnDetach=dispose_on_detach,
            proxyServer=proxy_server,
            proxyBypassList=proxy_bypass_list,
            originsWithUniversalNetworkAccess=origins_with_universal_network_access
        )


class GetBrowserContextsOutput(OutputModel):

    browserContextIds: list[Browser.BrowserContextID]


class GetBrowserContexts(CDPMethod[GetBrowserContextsOutput]):
    """ Returns all browser contexts created with `Target.createBrowserContext` method. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = GetBrowserContextsOutput


class CreateTargetInput(InputModel):

    url: str
    left: int | None = None  # experimental
    top: int | None = None  # experimental
    width: int | None = None
    height: int | None = None
    windowState: Target.WindowState | None = None
    browserContextId: Browser.BrowserContextID | None = None  # experimental
    enableBeginFrameControl: bool | None = None  # experimental
    newWindow: bool | None = None
    background: bool | None = None
    forTab: bool | None = None  # experimental
    hidden: bool | None = None  # experimental


class CreateTargetOutput(OutputModel):

    targetId: Target.TargetID


class CreateTarget(CDPMethod[CreateTargetOutput]):
    """ Creates a new page. """

    INPUT_VALIDATOR = CreateTargetInput
    OUTPUT_VALIDATOR = CreateTargetOutput

    def __init__(
        self,
        *,
        url: str,
        left: int | None = None,
        top: int | None = None,
        width: int | None = None,
        height: int | None = None,
        window_state: Target.WindowState | None = None,
        browser_context_id: Browser.BrowserContextID | None = None,
        enable_begin_frame_control: bool | None = None,
        new_window: bool | None = None,
        background: bool | None = None,
        for_tab: bool | None = None,
        hidden: bool | None = None
    ):
        super().__init__(
            url=url,
            left=left,
            top=top,
            width=width,
            height=height,
            windowState=window_state,
            browserContextId=browser_context_id,
            enableBeginFrameControl=enable_begin_frame_control,
            newWindow=new_window,
            background=background,
            forTab=for_tab,
            hidden=hidden
        )


class DetachFromTargetInput(InputModel):

    sessionId: Target.SessionID | None = None
    targetId: Target.TargetID | None = None  # deprecated


class DetachFromTarget(CDPMethod[None]):
    """ Detaches session with given id. """

    INPUT_VALIDATOR = DetachFromTargetInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        session_id: Target.SessionID | None = None,
        target_id: Target.TargetID | None = None
    ):
        super().__init__(
            sessionId=session_id,
            targetId=target_id
        )


class DisposeBrowserContextInput(InputModel):

    browserContextId: Browser.BrowserContextID


class DisposeBrowserContext(CDPMethod[None]):
    """ Deletes a BrowserContext. All the belonging pages will be closed without calling their
    beforeunload hooks. """

    INPUT_VALIDATOR = DisposeBrowserContextInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        browser_context_id: Browser.BrowserContextID
    ):
        super().__init__(
            browserContextId=browser_context_id
        )


class GetTargetInfoInput(InputModel):

    targetId: Target.TargetID | None = None


class GetTargetInfoOutput(OutputModel):

    targetInfo: Target.TargetInfo


class GetTargetInfo(CDPMethod[GetTargetInfoOutput]):  # experimental
    """ Returns information about a target. """

    INPUT_VALIDATOR = GetTargetInfoInput
    OUTPUT_VALIDATOR = GetTargetInfoOutput

    def __init__(
        self,
        *,
        target_id: Target.TargetID | None = None
    ):
        super().__init__(
            targetId=target_id
        )


class GetTargetsInput(InputModel):

    filter: Target.TargetFilter | None = None  # experimental


class GetTargetsOutput(OutputModel):

    targetInfos: list[Target.TargetInfo]


class GetTargets(CDPMethod[GetTargetsOutput]):
    """ Retrieves a list of available targets. """

    INPUT_VALIDATOR = GetTargetsInput
    OUTPUT_VALIDATOR = GetTargetsOutput

    def __init__(
        self,
        *,
        filter_: Target.TargetFilter | None = None
    ):
        super().__init__(
            filter=filter_
        )


class SendMessageToTargetInput(InputModel):

    message: str
    sessionId: Target.SessionID | None = None
    targetId: Target.TargetID | None = None  # deprecated


class SendMessageToTarget(CDPMethod[None]):  # deprecated
    """ Sends protocol message over session with given id.
    Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
    and crbug.com/991325. """

    INPUT_VALIDATOR = SendMessageToTargetInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        message: str,
        session_id: Target.SessionID | None = None,
        target_id: Target.TargetID | None = None
    ):
        super().__init__(
            message=message,
            sessionId=session_id,
            targetId=target_id
        )


class SetAutoAttachInput(InputModel):

    autoAttach: bool
    waitForDebuggerOnStart: bool
    flatten: bool | None = None  # experimental
    filter: Target.TargetFilter | None = None  # experimental


class SetAutoAttach(CDPMethod[None]):
    """ Controls whether to automatically attach to new targets which are considered
    to be directly related to this one (for example, iframes or workers).
    When turned on, attaches to all existing related targets as well. When turned off,
    automatically detaches from all currently attached targets.
    This also clears all targets added by `autoAttachRelated` from the list of targets to watch
    for creation of related targets.
    You might want to call this recursively for auto-attached targets to attach
    to all available targets. """

    INPUT_VALIDATOR = SetAutoAttachInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        auto_attach: bool,
        wait_for_debugger_on_start: bool,
        flatten: bool | None = None,
        filter_: Target.TargetFilter | None = None
    ):
        super().__init__(
            autoAttach=auto_attach,
            waitForDebuggerOnStart=wait_for_debugger_on_start,
            flatten=flatten,
            filter=filter_
        )


class AutoAttachRelatedInput(InputModel):

    targetId: Target.TargetID
    waitForDebuggerOnStart: bool
    filter: Target.TargetFilter | None = None  # experimental


class AutoAttachRelated(CDPMethod[None]):  # experimental
    """ Adds the specified target to the list of targets that will be monitored for any related target
    creation (such as child frames, child workers and new versions of service worker) and reported
    through `attachedToTarget`. The specified target is also auto-attached.
    This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
    `setAutoAttach`. Only available at the Browser target. """

    INPUT_VALIDATOR = AutoAttachRelatedInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        target_id: Target.TargetID,
        wait_for_debugger_on_start: bool,
        filter_: Target.TargetFilter | None = None
    ):
        super().__init__(
            targetId=target_id,
            waitForDebuggerOnStart=wait_for_debugger_on_start,
            filter=filter_
        )


class SetDiscoverTargetsInput(InputModel):

    discover: bool
    filter: Target.TargetFilter | None = None  # experimental


class SetDiscoverTargets(CDPMethod[None]):
    """ Controls whether to discover available targets and notify via
    `targetCreated/targetInfoChanged/targetDestroyed` events. """

    INPUT_VALIDATOR = SetDiscoverTargetsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        discover: bool,
        filter_: Target.TargetFilter | None = None
    ):
        super().__init__(
            discover=discover,
            filter=filter_
        )


class SetRemoteLocationsInput(InputModel):

    locations: list[Target.RemoteLocation]


class SetRemoteLocations(CDPMethod[None]):  # experimental
    """ Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
    `true`. """

    INPUT_VALIDATOR = SetRemoteLocationsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        locations: list[Target.RemoteLocation]
    ):
        super().__init__(
            locations=locations
        )
