"""
This file is generated by generator/run.py based on the Chrome DevTools Protocol.

Network domain allows tracking network activities of the page. It exposes information about http,
file, data and other requests and responses, their headers, bodies, timing, etc.
https://chromedevtools.github.io/devtools-protocol/tot/Network/

***************************************************
                    Methods
***************************************************
"""
from __future__ import annotations

from cdpkit.protocol._types import (
    IO,
    Debugger,
    Emulation,
    Network,
    Page,
)
from cdpkit.protocol.base import CDPMethod, InputModel, OutputModel


class SetAcceptedEncodingsInput(InputModel):

    encodings: list[Network.ContentEncoding]


class SetAcceptedEncodings(CDPMethod[None]):  # experimental
    """ Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted. """

    INPUT_VALIDATOR = SetAcceptedEncodingsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        encodings: list[Network.ContentEncoding]
    ):
        super().__init__(
            encodings=encodings
        )


class ClearAcceptedEncodingsOverride(CDPMethod[None]):  # experimental
    """ Clears accepted encodings set by setAcceptedEncodings """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class CanClearBrowserCacheOutput(OutputModel):

    result: bool


class CanClearBrowserCache(CDPMethod[CanClearBrowserCacheOutput]):  # deprecated
    """ Tells whether clearing browser cache is supported. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = CanClearBrowserCacheOutput


class CanClearBrowserCookiesOutput(OutputModel):

    result: bool


class CanClearBrowserCookies(CDPMethod[CanClearBrowserCookiesOutput]):  # deprecated
    """ Tells whether clearing browser cookies is supported. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = CanClearBrowserCookiesOutput


class CanEmulateNetworkConditionsOutput(OutputModel):

    result: bool


class CanEmulateNetworkConditions(CDPMethod[CanEmulateNetworkConditionsOutput]):  # deprecated
    """ Tells whether emulation of network conditions is supported. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = CanEmulateNetworkConditionsOutput


class ClearBrowserCache(CDPMethod[None]):
    """ Clears browser cache. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class ClearBrowserCookies(CDPMethod[None]):
    """ Clears browser cookies. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class ContinueInterceptedRequestInput(InputModel):

    interceptionId: Network.InterceptionId
    errorReason: Network.ErrorReason | None = None
    rawResponse: str | None = None
    url: str | None = None
    method: str | None = None
    postData: str | None = None
    headers: Network.Headers | None = None
    authChallengeResponse: Network.AuthChallengeResponse | None = None


class ContinueInterceptedRequest(CDPMethod[None]):  # experimental deprecated
    """ Response to Network.requestIntercepted which either modifies the request to continue with any
    modifications, or blocks it, or completes it with the provided response bytes. If a network
    fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
    event will be sent with the same InterceptionId.
    Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. """

    INPUT_VALIDATOR = ContinueInterceptedRequestInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        interception_id: Network.InterceptionId,
        error_reason: Network.ErrorReason | None = None,
        raw_response: str | None = None,
        url: str | None = None,
        method: str | None = None,
        post_data: str | None = None,
        headers: Network.Headers | None = None,
        auth_challenge_response: Network.AuthChallengeResponse | None = None
    ):
        super().__init__(
            interceptionId=interception_id,
            errorReason=error_reason,
            rawResponse=raw_response,
            url=url,
            method=method,
            postData=post_data,
            headers=headers,
            authChallengeResponse=auth_challenge_response
        )


class DeleteCookiesInput(InputModel):

    name: str
    url: str | None = None
    domain: str | None = None
    path: str | None = None
    partitionKey: Network.CookiePartitionKey | None = None  # experimental


class DeleteCookies(CDPMethod[None]):
    """ Deletes browser cookies with matching name and url or domain/path/partitionKey pair. """

    INPUT_VALIDATOR = DeleteCookiesInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        name: str,
        url: str | None = None,
        domain: str | None = None,
        path: str | None = None,
        partition_key: Network.CookiePartitionKey | None = None
    ):
        super().__init__(
            name=name,
            url=url,
            domain=domain,
            path=path,
            partitionKey=partition_key
        )


class Disable(CDPMethod[None]):
    """ Disables network tracking, prevents network events from being sent to the client. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = None


class EmulateNetworkConditionsInput(InputModel):

    offline: bool
    latency: float
    downloadThroughput: float
    uploadThroughput: float
    connectionType: Network.ConnectionType | None = None
    packetLoss: float | None = None  # experimental
    packetQueueLength: int | None = None  # experimental
    packetReordering: bool | None = None  # experimental


class EmulateNetworkConditions(CDPMethod[None]):
    """ Activates emulation of network conditions. """

    INPUT_VALIDATOR = EmulateNetworkConditionsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        offline: bool,
        latency: float,
        download_throughput: float,
        upload_throughput: float,
        connection_type: Network.ConnectionType | None = None,
        packet_loss: float | None = None,
        packet_queue_length: int | None = None,
        packet_reordering: bool | None = None
    ):
        super().__init__(
            offline=offline,
            latency=latency,
            downloadThroughput=download_throughput,
            uploadThroughput=upload_throughput,
            connectionType=connection_type,
            packetLoss=packet_loss,
            packetQueueLength=packet_queue_length,
            packetReordering=packet_reordering
        )


class EnableInput(InputModel):

    maxTotalBufferSize: int | None = None  # experimental
    maxResourceBufferSize: int | None = None  # experimental
    maxPostDataSize: int | None = None
    reportDirectSocketTraffic: bool | None = None  # experimental


class Enable(CDPMethod[None]):
    """ Enables network tracking, network events will now be delivered to the client. """

    INPUT_VALIDATOR = EnableInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        max_total_buffer_size: int | None = None,
        max_resource_buffer_size: int | None = None,
        max_post_data_size: int | None = None,
        report_direct_socket_traffic: bool | None = None
    ):
        super().__init__(
            maxTotalBufferSize=max_total_buffer_size,
            maxResourceBufferSize=max_resource_buffer_size,
            maxPostDataSize=max_post_data_size,
            reportDirectSocketTraffic=report_direct_socket_traffic
        )


class GetAllCookiesOutput(OutputModel):

    cookies: list[Network.Cookie]


class GetAllCookies(CDPMethod[GetAllCookiesOutput]):  # deprecated
    """ Returns all browser cookies. Depending on the backend support, will return detailed cookie
    information in the `cookies` field.
    Deprecated. Use Storage.getCookies instead. """

    INPUT_VALIDATOR = None
    OUTPUT_VALIDATOR = GetAllCookiesOutput


class GetCertificateInput(InputModel):

    origin: str


class GetCertificateOutput(OutputModel):

    tableNames: list[str]


class GetCertificate(CDPMethod[GetCertificateOutput]):  # experimental
    """ Returns the DER-encoded certificate. """

    INPUT_VALIDATOR = GetCertificateInput
    OUTPUT_VALIDATOR = GetCertificateOutput

    def __init__(
        self,
        *,
        origin: str
    ):
        super().__init__(
            origin=origin
        )


class GetCookiesInput(InputModel):

    urls: list[str] | None = None


class GetCookiesOutput(OutputModel):

    cookies: list[Network.Cookie]


class GetCookies(CDPMethod[GetCookiesOutput]):
    """ Returns all browser cookies for the current URL. Depending on the backend support, will return
    detailed cookie information in the `cookies` field. """

    INPUT_VALIDATOR = GetCookiesInput
    OUTPUT_VALIDATOR = GetCookiesOutput

    def __init__(
        self,
        *,
        urls: list[str] | None = None
    ):
        super().__init__(
            urls=urls
        )


class GetResponseBodyInput(InputModel):

    requestId: Network.RequestId


class GetResponseBodyOutput(OutputModel):

    body: str
    base64Encoded: bool


class GetResponseBody(CDPMethod[GetResponseBodyOutput]):
    """ Returns content served for the given request. """

    INPUT_VALIDATOR = GetResponseBodyInput
    OUTPUT_VALIDATOR = GetResponseBodyOutput

    def __init__(
        self,
        *,
        request_id: Network.RequestId
    ):
        super().__init__(
            requestId=request_id
        )


class GetRequestPostDataInput(InputModel):

    requestId: Network.RequestId


class GetRequestPostDataOutput(OutputModel):

    postData: str


class GetRequestPostData(CDPMethod[GetRequestPostDataOutput]):
    """ Returns post data sent with the request. Returns an error when no data was sent with the request. """

    INPUT_VALIDATOR = GetRequestPostDataInput
    OUTPUT_VALIDATOR = GetRequestPostDataOutput

    def __init__(
        self,
        *,
        request_id: Network.RequestId
    ):
        super().__init__(
            requestId=request_id
        )


class GetResponseBodyForInterceptionInput(InputModel):

    interceptionId: Network.InterceptionId


class GetResponseBodyForInterceptionOutput(OutputModel):

    body: str
    base64Encoded: bool


class GetResponseBodyForInterception(CDPMethod[GetResponseBodyForInterceptionOutput]):  # experimental
    """ Returns content served for the given currently intercepted request. """

    INPUT_VALIDATOR = GetResponseBodyForInterceptionInput
    OUTPUT_VALIDATOR = GetResponseBodyForInterceptionOutput

    def __init__(
        self,
        *,
        interception_id: Network.InterceptionId
    ):
        super().__init__(
            interceptionId=interception_id
        )


class TakeResponseBodyForInterceptionAsStreamInput(InputModel):

    interceptionId: Network.InterceptionId


class TakeResponseBodyForInterceptionAsStreamOutput(OutputModel):

    stream: IO.StreamHandle


class TakeResponseBodyForInterceptionAsStream(CDPMethod[TakeResponseBodyForInterceptionAsStreamOutput]):  # experimental
    """ Returns a handle to the stream representing the response body. Note that after this command,
    the intercepted request can't be continued as is -- you either need to cancel it or to provide
    the response body. The stream only supports sequential read, IO.read will fail if the position
    is specified. """

    INPUT_VALIDATOR = TakeResponseBodyForInterceptionAsStreamInput
    OUTPUT_VALIDATOR = TakeResponseBodyForInterceptionAsStreamOutput

    def __init__(
        self,
        *,
        interception_id: Network.InterceptionId
    ):
        super().__init__(
            interceptionId=interception_id
        )


class ReplayXHRInput(InputModel):

    requestId: Network.RequestId


class ReplayXHR(CDPMethod[None]):  # experimental
    """ This method sends a new XMLHttpRequest which is identical to the original one. The following
    parameters should be identical: method, url, async, request body, extra headers, withCredentials
    attribute, user, password. """

    INPUT_VALIDATOR = ReplayXHRInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        request_id: Network.RequestId
    ):
        super().__init__(
            requestId=request_id
        )


class SearchInResponseBodyInput(InputModel):

    requestId: Network.RequestId
    query: str
    caseSensitive: bool | None = None
    isRegex: bool | None = None


class SearchInResponseBodyOutput(OutputModel):

    result: list[Debugger.SearchMatch]


class SearchInResponseBody(CDPMethod[SearchInResponseBodyOutput]):  # experimental
    """ Searches for given string in response content. """

    INPUT_VALIDATOR = SearchInResponseBodyInput
    OUTPUT_VALIDATOR = SearchInResponseBodyOutput

    def __init__(
        self,
        *,
        request_id: Network.RequestId,
        query: str,
        case_sensitive: bool | None = None,
        is_regex: bool | None = None
    ):
        super().__init__(
            requestId=request_id,
            query=query,
            caseSensitive=case_sensitive,
            isRegex=is_regex
        )


class SetBlockedURLsInput(InputModel):

    urls: list[str]


class SetBlockedURLs(CDPMethod[None]):  # experimental
    """ Blocks URLs from loading. """

    INPUT_VALIDATOR = SetBlockedURLsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        urls: list[str]
    ):
        super().__init__(
            urls=urls
        )


class SetBypassServiceWorkerInput(InputModel):

    bypass: bool


class SetBypassServiceWorker(CDPMethod[None]):
    """ Toggles ignoring of service worker for each request. """

    INPUT_VALIDATOR = SetBypassServiceWorkerInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        bypass: bool
    ):
        super().__init__(
            bypass=bypass
        )


class SetCacheDisabledInput(InputModel):

    cacheDisabled: bool


class SetCacheDisabled(CDPMethod[None]):
    """ Toggles ignoring cache for each request. If `true`, cache will not be used. """

    INPUT_VALIDATOR = SetCacheDisabledInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        cache_disabled: bool
    ):
        super().__init__(
            cacheDisabled=cache_disabled
        )


class SetCookieInput(InputModel):

    name: str
    value: str
    url: str | None = None
    domain: str | None = None
    path: str | None = None
    secure: bool | None = None
    httpOnly: bool | None = None
    sameSite: Network.CookieSameSite | None = None
    expires: Network.TimeSinceEpoch | None = None
    priority: Network.CookiePriority | None = None  # experimental
    sameParty: bool | None = None  # experimental
    sourceScheme: Network.CookieSourceScheme | None = None  # experimental
    sourcePort: int | None = None  # experimental
    partitionKey: Network.CookiePartitionKey | None = None  # experimental


class SetCookieOutput(OutputModel):

    success: bool  # deprecated


class SetCookie(CDPMethod[SetCookieOutput]):
    """ Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. """

    INPUT_VALIDATOR = SetCookieInput
    OUTPUT_VALIDATOR = SetCookieOutput

    def __init__(
        self,
        *,
        name: str,
        value: str,
        url: str | None = None,
        domain: str | None = None,
        path: str | None = None,
        secure: bool | None = None,
        http_only: bool | None = None,
        same_site: Network.CookieSameSite | None = None,
        expires: Network.TimeSinceEpoch | None = None,
        priority: Network.CookiePriority | None = None,
        same_party: bool | None = None,
        source_scheme: Network.CookieSourceScheme | None = None,
        source_port: int | None = None,
        partition_key: Network.CookiePartitionKey | None = None
    ):
        super().__init__(
            name=name,
            value=value,
            url=url,
            domain=domain,
            path=path,
            secure=secure,
            httpOnly=http_only,
            sameSite=same_site,
            expires=expires,
            priority=priority,
            sameParty=same_party,
            sourceScheme=source_scheme,
            sourcePort=source_port,
            partitionKey=partition_key
        )


class SetCookiesInput(InputModel):

    cookies: list[Network.CookieParam]


class SetCookies(CDPMethod[None]):
    """ Sets given cookies. """

    INPUT_VALIDATOR = SetCookiesInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        cookies: list[Network.CookieParam]
    ):
        super().__init__(
            cookies=cookies
        )


class SetExtraHTTPHeadersInput(InputModel):

    headers: Network.Headers


class SetExtraHTTPHeaders(CDPMethod[None]):
    """ Specifies whether to always send extra HTTP headers with the requests from this page. """

    INPUT_VALIDATOR = SetExtraHTTPHeadersInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        headers: Network.Headers
    ):
        super().__init__(
            headers=headers
        )


class SetAttachDebugStackInput(InputModel):

    enabled: bool


class SetAttachDebugStack(CDPMethod[None]):  # experimental
    """ Specifies whether to attach a page script stack id in requests """

    INPUT_VALIDATOR = SetAttachDebugStackInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        enabled: bool
    ):
        super().__init__(
            enabled=enabled
        )


class SetRequestInterceptionInput(InputModel):

    patterns: list[Network.RequestPattern]


class SetRequestInterception(CDPMethod[None]):  # experimental deprecated
    """ Sets the requests to intercept that match the provided patterns and optionally resource types.
    Deprecated, please use Fetch.enable instead. """

    INPUT_VALIDATOR = SetRequestInterceptionInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        patterns: list[Network.RequestPattern]
    ):
        super().__init__(
            patterns=patterns
        )


class SetUserAgentOverrideInput(InputModel):

    userAgent: str
    acceptLanguage: str | None = None
    platform: str | None = None
    userAgentMetadata: Emulation.UserAgentMetadata | None = None  # experimental


class SetUserAgentOverride(CDPMethod[None]):
    """ Allows overriding user agent with the given string. """

    INPUT_VALIDATOR = SetUserAgentOverrideInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        user_agent: str,
        accept_language: str | None = None,
        platform: str | None = None,
        user_agent_metadata: Emulation.UserAgentMetadata | None = None
    ):
        super().__init__(
            userAgent=user_agent,
            acceptLanguage=accept_language,
            platform=platform,
            userAgentMetadata=user_agent_metadata
        )


class StreamResourceContentInput(InputModel):

    requestId: Network.RequestId


class StreamResourceContentOutput(OutputModel):

    bufferedData: str


class StreamResourceContent(CDPMethod[StreamResourceContentOutput]):  # experimental
    """ Enables streaming of the response for the given requestId.
    If enabled, the dataReceived event contains the data that was received during streaming. """

    INPUT_VALIDATOR = StreamResourceContentInput
    OUTPUT_VALIDATOR = StreamResourceContentOutput

    def __init__(
        self,
        *,
        request_id: Network.RequestId
    ):
        super().__init__(
            requestId=request_id
        )


class GetSecurityIsolationStatusInput(InputModel):

    frameId: Page.FrameId | None = None


class GetSecurityIsolationStatusOutput(OutputModel):

    status: Network.SecurityIsolationStatus


class GetSecurityIsolationStatus(CDPMethod[GetSecurityIsolationStatusOutput]):  # experimental
    """ Returns information about the COEP/COOP isolation status. """

    INPUT_VALIDATOR = GetSecurityIsolationStatusInput
    OUTPUT_VALIDATOR = GetSecurityIsolationStatusOutput

    def __init__(
        self,
        *,
        frame_id: Page.FrameId | None = None
    ):
        super().__init__(
            frameId=frame_id
        )


class EnableReportingApiInput(InputModel):

    enable: bool


class EnableReportingApi(CDPMethod[None]):  # experimental
    """ Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
    Enabling triggers 'reportingApiReportAdded' for all existing reports. """

    INPUT_VALIDATOR = EnableReportingApiInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        enable: bool
    ):
        super().__init__(
            enable=enable
        )


class LoadNetworkResourceInput(InputModel):

    frameId: Page.FrameId | None = None
    url: str
    options: Network.LoadNetworkResourceOptions


class LoadNetworkResourceOutput(OutputModel):

    resource: Network.LoadNetworkResourcePageResult


class LoadNetworkResource(CDPMethod[LoadNetworkResourceOutput]):  # experimental
    """ Fetches the resource and returns the content. """

    INPUT_VALIDATOR = LoadNetworkResourceInput
    OUTPUT_VALIDATOR = LoadNetworkResourceOutput

    def __init__(
        self,
        *,
        frame_id: Page.FrameId | None = None,
        url: str,
        options: Network.LoadNetworkResourceOptions
    ):
        super().__init__(
            frameId=frame_id,
            url=url,
            options=options
        )


class SetCookieControlsInput(InputModel):

    enableThirdPartyCookieRestriction: bool
    disableThirdPartyCookieMetadata: bool
    disableThirdPartyCookieHeuristics: bool


class SetCookieControls(CDPMethod[None]):  # experimental
    """ Sets Controls for third-party cookie access
    Page reload is required before the new cookie behavior will be observed """

    INPUT_VALIDATOR = SetCookieControlsInput
    OUTPUT_VALIDATOR = None

    def __init__(
        self,
        *,
        enable_third_party_cookie_restriction: bool,
        disable_third_party_cookie_metadata: bool,
        disable_third_party_cookie_heuristics: bool
    ):
        super().__init__(
            enableThirdPartyCookieRestriction=enable_third_party_cookie_restriction,
            disableThirdPartyCookieMetadata=disable_third_party_cookie_metadata,
            disableThirdPartyCookieHeuristics=disable_third_party_cookie_heuristics
        )
